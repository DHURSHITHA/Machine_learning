📘 Naive Bayes Classifier (From Scratch → Advanced)
1. Introduction

What is it?
Naive Bayes is a supervised learning algorithm based on Bayes’ theorem.
It is called "naive" because it assumes that all features are independent of each other (which is rarely true in real life, but still works surprisingly well).

Purpose:
Given some input features, it predicts the probability of each possible class and chooses the class with the highest probability.

Applications:

Text Classification: Spam detection, sentiment analysis.

Medical Diagnosis: Predicting diseases from symptoms.

Recommendation Systems: Suggesting movies, books, etc.

✅ Why important? Because it is fast, simple, and works well for text/categorical data.

2. Bayes’ Theorem (The Core)

Bayes’ theorem is a formula for finding the posterior probability:

Where:

P(C|X): Posterior → Probability of class 
𝐶
C given data 
𝑋
X. (What we want to find!)

P(X|C): Likelihood → Probability of seeing data 
𝑋
X if the class is 
𝐶
C.

P(C): Prior → Probability of class 
𝐶
C before seeing data.

P(X): Evidence → Probability of the data overall (normalization factor).

🔑 Intuition:
It updates our belief about the class after seeing the evidence.

3. The "Naive" Assumption

P(X∣C) could be very complex because 
𝑋
X may have many features.
Naive Bayes assumes features are independent given the class.

That means:

This simplifies computation drastically.

4. Types of Naive Bayes

Gaussian Naive Bayes

For continuous features.

Assumes features follow a Normal distribution.

Example: Predicting height/weight distribution of males vs females.

Multinomial Naive Bayes

For discrete features (like word counts).

Example: Text classification (word frequencies in emails).

Bernoulli Naive Bayes

For binary features (0/1 presence of word).

Example: Whether a word (“offer”) appears in spam or not.

5. Mathematical Formulation

Prior Probability (P(C))

Probability of each class in training data.

Example: 60% spam emails, 40% non-spam.

Likelihood (P(X|C))

Probability of feature values given class.

Example: Probability that word “free” appears in spam.

Posterior (P(C|X))

Computed using Bayes’ formula.

Decision Rule:

Choose class with highest posterior:
P(C∣X)
6. Implementation Steps
Data Preprocessing

Feature scaling: ❌ Not required.

Handle missing values: Use imputation.

Encode categorical variables: One-hot encoding.

Training

Use Scikit-learn (GaussianNB, MultinomialNB, BernoulliNB).

Fit with training data.

Prediction

Use .predict() to classify new data.

Hyperparameters

Smoothing (Laplace smoothing / α):
Avoids zero probability for unseen words/features.
(Very important in text classification).

7. Evaluation Metrics

Accuracy → % of correct predictions.

Precision → Of predicted positives, how many are correct?

Recall → Of actual positives, how many did we catch?

F1-score → Balance between precision & recall.

Confusion Matrix → Table of TP, FP, TN, FN.

✅ Use cross-validation (like k-fold) to ensure generalization.

8. Advantages

Simple, easy, and fast.

Works well with large datasets and high-dimensional data (like text).

Handles categorical features very well.

Can work with missing/irrelevant features.

9. Limitations

Independence assumption is often false in real-world data.

Doesn’t perform well when features are correlated.

Less powerful than advanced models (e.g., Random Forest, Neural Networks).

10. Practical Considerations

Imbalanced Data: Adjust priors or thresholds.

Feature Engineering: Choose useful features, remove noisy ones.

Interpretability: Easy to explain because it gives probabilities.

11. Real-World Applications

Text Classification: Spam filtering, sentiment analysis.

Healthcare: Disease prediction from symptoms.

Finance: Fraud detection, credit risk scoring.

12. Conclusion

Naive Bayes is based on Bayes’ theorem + independence assumption.

It is simple yet powerful, especially in text classification.

Works best for categorical data and situations where speed is important.

Limitations: Doesn’t capture correlations well, so not always best for complex data.

✅ Exam Tip: Always write:

Definition + Formula.

Assumptions.

Types (Gaussian, Multinomial, Bernoulli).

Applications.

Advantages & Limitations.

Example (like spam filtering).





🌳 Decision Trees (Basics → Advanced)
1. What is a Decision Tree?

A Decision Tree is a supervised learning algorithm used for Classification and Regression.

Supervised → You give input data with labels (like student marks + Pass/Fail).

Tree-like structure → Looks like a flowchart with questions → answers → outcomes.

👉 Example:
Imagine you want to decide whether to play cricket today.

Root Question: Is it raining?

Yes → Leaf: Don’t play.

No → Next Question: Is the ground wet?

Yes → Leaf: Don’t play.

No → Leaf: Play cricket!

This simple decision-making process is how decision trees work.

2. Terminologies

Root Node → Starting point (whole dataset).

Decision Node → A node where a condition/question is asked.

Leaf/Terminal Node → Final output (Yes/No, Pass/Fail, etc.).

Branch/Sub-tree → Path from root to a leaf.

Parent & Child Node → A node splits into child nodes.

Pruning → Cutting unnecessary branches to avoid overfitting.

3. How a Decision Tree Works

Start at the root node with all data.

Pick the best feature (question) to split data → based on Impurity measures (like Gini or Entropy).

Split into subsets (branches).

Repeat step 2 for each branch until:

Pure class (all samples same)

No features left

Or stopping criteria reached (max depth, min samples).

The last nodes are Leaf nodes (predictions).

4. Assumptions in Decision Trees

Binary Splits → Each split is Yes/No type.

Recursive Partitioning → Repeatedly divide data.

Feature Independence → Features are considered independent.

Homogeneity → Aim for similar data in a node.

Top-Down Greedy → Always pick the best split at that step (not globally best).

Handles categorical & numerical features.

Sensitive to overfitting, outliers, and sample size.

5. Impurity Measures

To decide the “best split,” we need metrics:

Entropy (Information Gain) → Measures disorder. Lower entropy → better split.

Gini Index → Measures probability of wrong classification. Lower Gini → better split.

👉 Example:
If we have students labeled Pass and Fail:

Before split: Mixed → High entropy.

After split: Pure groups (all Pass in one, all Fail in another) → Low entropy.

6. Advantages & Disadvantages

✅ Easy to understand and interpret.
✅ Handles both categorical and numerical data.
✅ No need for scaling/normalization.

❌ Overfits easily.
❌ Sensitive to outliers.
❌ Can create biased trees if dataset is unbalanced.

🌲 Random Forest (Ensemble Method)
1. What is Random Forest?

Random Forest = Many Decision Trees combined.
It’s an ensemble algorithm → combines results of multiple models to improve accuracy.

Instead of one decision tree, it builds many trees.

Each tree is trained on:

Random subset of data (Bagging method).

Random subset of features.

Final prediction:

Classification → Majority voting (most common output among trees).

Regression → Average of outputs.

👉 Example:
Think of asking 10 doctors for advice instead of just 1. Final decision = majority opinion = more reliable.

2. Working of Random Forest

Take dataset.

Pick random samples with replacement (bootstrap sampling).

Train a decision tree on each sample, but only with a random subset of features.

Combine results of all trees.

This randomness prevents overfitting and improves generalization.

3. Random Forest vs Decision Tree
Feature	Decision Tree	Random Forest
Model type	Single tree	Many trees (ensemble)
Overfitting	High chance	Reduced
Accuracy	Lower	Higher
Speed	Faster	Slower (many trees)
Output	Rules from one tree	Majority vote / average
📝 Exam-Oriented Summary

Decision Tree: Root → split using impurity → repeat → leaf nodes.

Impurity measures: Gini, Entropy.

Pruning: Removes unnecessary nodes → avoids overfitting.

Random Forest: Ensemble of trees using bagging + random feature selection.

Advantages: Handles both regression & classification, reduces overfitting, improves accuracy.






1. What is Regression?

Regression is a statistical + machine learning method that finds the relationship between variables.

It predicts a continuous value (numbers, not categories).

👉 Example:

Predicting house price based on size, location, and number of rooms.

Predicting salary based on years of experience.

Dependent variable (output) = the value we want to predict (Y).

Independent variable(s) (input features) = the factors we use to predict (X).

2. Key Terms in Regression

Dependent Variable (Y) → The target (e.g., House Price).

Independent Variables (X) → Predictors (e.g., Size, Rooms).

Regression Coefficients (β₀, β₁, β₂… ) → Numbers that represent how much each X affects Y.

Regression Line → Best-fit line that represents the relationship.

Residuals → Difference between actual and predicted values.

Residual = Actual – Predicted.

Loss Function → Formula to measure error.

MSE (Mean Squared Error) = average of squared residuals.

MAE (Mean Absolute Error) = average of absolute residuals.

Overfitting → Model is too complex, memorizes data, performs badly on new data.

Underfitting → Model is too simple, cannot capture patterns.

Regularization → Techniques (like Ridge, Lasso) to reduce overfitting by penalizing large coefficients.

3. Types of Regression Algorithms

Linear Regression

Decision Tree Regression

Support Vector Regression (SVR)

Lasso Regression

Random Forest Regression

Let’s start with Linear Regression (the most fundamental one).

4. Linear Regression

Linear Regression assumes the relationship between variables is linear (a straight line).

y = dependent variable (house price).

x = independent variable (house size).

β₀ = intercept (base value when x=0).

β₁ = slope (how much y changes when x increases by 1).

ε = error term (random variation not explained by x).

Example 1: Simple Linear Regression

Dataset: House size (sq ft) vs Price.

Suppose after training, we get


+$100 for each sq. ft.

+$20,000 for each bedroom

+$30,000 if location is better

👉 This is Multiple Linear Regression (more than 1 predictor).

Types of Relationships

Positive Linear Relationship → X ↑, Y ↑
(e.g., more study hours → higher marks).

Negative Linear Relationship → X ↑, Y ↓
(e.g., more exercise → lower body fat).

Finding the Best Fit Line

We try many possible lines → choose the one with minimum error.

Error measured using Cost Function (commonly MSE).

Optimization method: Gradient Descent (iteratively adjusts β₀, β₁… to minimize error).

5. Pros & Cons of Linear Regression

✅ Pros:

Simple and easy to implement.

Works well for linearly related data.

Fast and efficient.

❌ Cons:

Very sensitive to outliers (extreme values affect the line).

Assumes a linear relationship, but real-world data may not be linear.

Can overfit with too many predictors.

6. Extensions of Linear Regression

Polynomial Regression → If relationship is curved, we add powers of x.

Ridge Regression → Penalizes large coefficients (reduces overfitting).

Lasso Regression → Shrinks some coefficients to 0 (helps in feature selection).

📝 Exam-Oriented Summary

Regression = predicting continuous values (e.g., price, salary).

Key terms: Dependent/Independent vars, Coefficients, Residuals, Loss function.

Types:

Simple Linear Regression (1 predictor).

Multiple Linear Regression (many predictors).

Error Measurement: MSE, MAE.

Problems: Overfitting, Underfitting, Outliers.

Solutions: Regularization (Ridge, Lasso).