📘 Naive Bayes Classifier (From Scratch → Advanced)
1. Introduction

What is it?
Naive Bayes is a supervised learning algorithm based on Bayes’ theorem.
It is called "naive" because it assumes that all features are independent of each other (which is rarely true in real life, but still works surprisingly well).

Purpose:
Given some input features, it predicts the probability of each possible class and chooses the class with the highest probability.

Applications:

Text Classification: Spam detection, sentiment analysis.

Medical Diagnosis: Predicting diseases from symptoms.

Recommendation Systems: Suggesting movies, books, etc.

✅ Why important? Because it is fast, simple, and works well for text/categorical data.

2. Bayes’ Theorem (The Core)

Bayes’ theorem is a formula for finding the posterior probability:

Where:

P(C|X): Posterior → Probability of class 
𝐶
C given data 
𝑋
X. (What we want to find!)

P(X|C): Likelihood → Probability of seeing data 
𝑋
X if the class is 
𝐶
C.

P(C): Prior → Probability of class 
𝐶
C before seeing data.

P(X): Evidence → Probability of the data overall (normalization factor).

🔑 Intuition:
It updates our belief about the class after seeing the evidence.

3. The "Naive" Assumption

P(X∣C) could be very complex because 
𝑋
X may have many features.
Naive Bayes assumes features are independent given the class.

That means:

This simplifies computation drastically.

4. Types of Naive Bayes

Gaussian Naive Bayes

For continuous features.

Assumes features follow a Normal distribution.

Example: Predicting height/weight distribution of males vs females.

Multinomial Naive Bayes

For discrete features (like word counts).

Example: Text classification (word frequencies in emails).

Bernoulli Naive Bayes

For binary features (0/1 presence of word).

Example: Whether a word (“offer”) appears in spam or not.

5. Mathematical Formulation

Prior Probability (P(C))

Probability of each class in training data.

Example: 60% spam emails, 40% non-spam.

Likelihood (P(X|C))

Probability of feature values given class.

Example: Probability that word “free” appears in spam.

Posterior (P(C|X))

Computed using Bayes’ formula.

Decision Rule:

Choose class with highest posterior:
P(C∣X)
6. Implementation Steps
Data Preprocessing

Feature scaling: ❌ Not required.

Handle missing values: Use imputation.

Encode categorical variables: One-hot encoding.

Training

Use Scikit-learn (GaussianNB, MultinomialNB, BernoulliNB).

Fit with training data.

Prediction

Use .predict() to classify new data.

Hyperparameters

Smoothing (Laplace smoothing / α):
Avoids zero probability for unseen words/features.
(Very important in text classification).

7. Evaluation Metrics

Accuracy → % of correct predictions.

Precision → Of predicted positives, how many are correct?

Recall → Of actual positives, how many did we catch?

F1-score → Balance between precision & recall.

Confusion Matrix → Table of TP, FP, TN, FN.

✅ Use cross-validation (like k-fold) to ensure generalization.

8. Advantages

Simple, easy, and fast.

Works well with large datasets and high-dimensional data (like text).

Handles categorical features very well.

Can work with missing/irrelevant features.

9. Limitations

Independence assumption is often false in real-world data.

Doesn’t perform well when features are correlated.

Less powerful than advanced models (e.g., Random Forest, Neural Networks).

10. Practical Considerations

Imbalanced Data: Adjust priors or thresholds.

Feature Engineering: Choose useful features, remove noisy ones.

Interpretability: Easy to explain because it gives probabilities.

11. Real-World Applications

Text Classification: Spam filtering, sentiment analysis.

Healthcare: Disease prediction from symptoms.

Finance: Fraud detection, credit risk scoring.

12. Conclusion

Naive Bayes is based on Bayes’ theorem + independence assumption.

It is simple yet powerful, especially in text classification.

Works best for categorical data and situations where speed is important.

Limitations: Doesn’t capture correlations well, so not always best for complex data.

✅ Exam Tip: Always write:

Definition + Formula.

Assumptions.

Types (Gaussian, Multinomial, Bernoulli).

Applications.

Advantages & Limitations.

Example (like spam filtering).





🌳 Decision Trees (Basics → Advanced)
1. What is a Decision Tree?

A Decision Tree is a supervised learning algorithm used for Classification and Regression.

Supervised → You give input data with labels (like student marks + Pass/Fail).

Tree-like structure → Looks like a flowchart with questions → answers → outcomes.

👉 Example:
Imagine you want to decide whether to play cricket today.

Root Question: Is it raining?

Yes → Leaf: Don’t play.

No → Next Question: Is the ground wet?

Yes → Leaf: Don’t play.

No → Leaf: Play cricket!

This simple decision-making process is how decision trees work.

2. Terminologies

Root Node → Starting point (whole dataset).

Decision Node → A node where a condition/question is asked.

Leaf/Terminal Node → Final output (Yes/No, Pass/Fail, etc.).

Branch/Sub-tree → Path from root to a leaf.

Parent & Child Node → A node splits into child nodes.

Pruning → Cutting unnecessary branches to avoid overfitting.

3. How a Decision Tree Works

Start at the root node with all data.

Pick the best feature (question) to split data → based on Impurity measures (like Gini or Entropy).

Split into subsets (branches).

Repeat step 2 for each branch until:

Pure class (all samples same)

No features left

Or stopping criteria reached (max depth, min samples).

The last nodes are Leaf nodes (predictions).

4. Assumptions in Decision Trees

Binary Splits → Each split is Yes/No type.

Recursive Partitioning → Repeatedly divide data.

Feature Independence → Features are considered independent.

Homogeneity → Aim for similar data in a node.

Top-Down Greedy → Always pick the best split at that step (not globally best).

Handles categorical & numerical features.

Sensitive to overfitting, outliers, and sample size.

5. Impurity Measures

To decide the “best split,” we need metrics:

Entropy (Information Gain) → Measures disorder. Lower entropy → better split.

Gini Index → Measures probability of wrong classification. Lower Gini → better split.

👉 Example:
If we have students labeled Pass and Fail:

Before split: Mixed → High entropy.

After split: Pure groups (all Pass in one, all Fail in another) → Low entropy.

6. Advantages & Disadvantages

✅ Easy to understand and interpret.
✅ Handles both categorical and numerical data.
✅ No need for scaling/normalization.

❌ Overfits easily.
❌ Sensitive to outliers.
❌ Can create biased trees if dataset is unbalanced.

🌲 Random Forest (Ensemble Method)
1. What is Random Forest?

Random Forest = Many Decision Trees combined.
It’s an ensemble algorithm → combines results of multiple models to improve accuracy.

Instead of one decision tree, it builds many trees.

Each tree is trained on:

Random subset of data (Bagging method).

Random subset of features.

Final prediction:

Classification → Majority voting (most common output among trees).

Regression → Average of outputs.

👉 Example:
Think of asking 10 doctors for advice instead of just 1. Final decision = majority opinion = more reliable.

2. Working of Random Forest

Take dataset.

Pick random samples with replacement (bootstrap sampling).

Train a decision tree on each sample, but only with a random subset of features.

Combine results of all trees.

This randomness prevents overfitting and improves generalization.

3. Random Forest vs Decision Tree
Feature	Decision Tree	Random Forest
Model type	Single tree	Many trees (ensemble)
Overfitting	High chance	Reduced
Accuracy	Lower	Higher
Speed	Faster	Slower (many trees)
Output	Rules from one tree	Majority vote / average
📝 Exam-Oriented Summary

Decision Tree: Root → split using impurity → repeat → leaf nodes.

Impurity measures: Gini, Entropy.

Pruning: Removes unnecessary nodes → avoids overfitting.

Random Forest: Ensemble of trees using bagging + random feature selection.

Advantages: Handles both regression & classification, reduces overfitting, improves accuracy.